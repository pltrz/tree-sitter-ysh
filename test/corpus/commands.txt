=========================
Command with no arguments
=========================
cat
---
(program
  (command_call
    (command_name
      (word))))

==============================
Command with literal arguments
==============================
echo "foo" bar 12
---
(program
  (command_call
    (command_name
      (word))
    (string)
    (word)
    (number)))

==============================
Command parameter with # in it
==============================
echo not#comment
---
(program
 (command_call
  (command_name
    (word))
  (word)))
==================
Multiline commands
==================
... find /bin               # traverse this directory and
    -type f -a -executable  # print executable files
  | sort -r                 # reverse sort
  # inline comment
  | head -n 30              # limit to 30 files
  ;

... echo
    works!; # with comment

... echo "new command" ;
---
(program
  (multiline_command_call
    (command_name
      (word))
    (word)
    (comment)
    (word)
    (word)
    (word)
    (word)
    (comment)
    (command_call
      (command_name
        (word))
      (word))
    (comment)
    (comment)
    (command_call
      (command_name
        (word))
      (word)
      (number))
    (comment))
  (multiline_command_call
    (command_name
      (word))
    (word))
  (comment)
  (multiline_command_call
    (command_name
      (word))
    (string)))
============
Call builtin
============
call myplace->setValue(42)
---
(program
  (expression_mode
    (variable_name)
    (method_call
      (function_name
        (variable_name))
      (number))))
=========
Expansion
=========
echo $? $* $#
---
(program
  (command_call
    (command_name
      (word))
    (expansion
      (variable_name))
    (expansion
      (variable_name))
    (expansion
      (variable_name))))
=======================================
Expansion in command with default value
=======================================
echo ${not_defined:-'default'}
---
(program
  (command_call
    (command_name
      (word))
    (expansion
      (variable_name)
      (string))))
=======================================
Invalid expansion
:error
=======================================
echo $ myvar
---
=======================================
Command call with positional, typed arg
=======================================
pp value ([1, 2])
---
(program
  (command_call
    (command_name
      (word))
    (word)
    (parameter_list_call
      (list
        (number)
        (number)))))
=============================
Command call with value.Place
=============================
json read (&mydict)
---
(program
  (command_call
    (command_name
      (word))
    (word)
    (parameter_list_call
      (unary_expression
        (variable_name)))))
============
Array splice
============
write @foods
---
(program
  (command_call
    (command_name
      (word))
    (expansion
      (variable_name))))
=====
Pipes
=====
cat myfile.csv | cut -d" " -f2 | sort | uniq
---
(program
  (command_call
    (command_name
      (word))
    (word)
    (command_call
      (command_name
        (word))
      (word)
      (string)
      (word)
      (command_call
        (command_name
          (word))
        (command_call
          (command_name
            (word)))))))
========================
Prefix environment value
========================
PYTHONPATH=vendor python3
MYENV= echo noop
PATH="$PATH:/usr/local/bin" mycmd
---
(program
  (command_call
    (environment
      (variable_name)
      (word))
    (command_name
      (word)))
  (command_call
    (environment
      (variable_name))
    (command_name
      (word))
    (word))
  (command_call
    (environment
      (variable_name)
      (string
        (expansion
          (variable_name))))
    (command_name
      (word))))
===========
Redirection
===========
echo hi > tmp.txt
ls 2> errors.txt
sort < tmp.txt
ls /tmp 2>errors.txt
echo 'fatal error' >&2
json write > foo.json ({x: 42})
json read (&mydict) < foo.json
---
(program
  (command_call
    (command_name
      (word))
    (word)
    (redirection
      (word)))
  (command_call
    (command_name
      (word))
    (redirection
      (number)
      (word)))
  (command_call
    (command_name
      (word))
    (redirection
      (word)))
  (command_call
    (command_name
      (word))
    (word)
    (redirection
      (number)
      (word)))
  (command_call
    (command_name
      (word))
    (string)
    (redirection
      (number)))
  (command_call
    (command_name
      (word))
    (word)
    (redirection
      (word))
    (parameter_list_call
      (dict
        (variable_name)
        (number))))
  (command_call
    (command_name
      (word))
    (word)
    (parameter_list_call
      (unary_expression
        (variable_name)))
    (redirection
      (word))))
====================
Expansion as command
====================
@ARGV
---
(program
  (command_call
    (command_name
      (expansion
        (variable_name)))))
======================================
Command arguments with trailing commas
======================================
json write (space=0, { status: 302, headers: { location: '/', }, },)
---
(program
  (command_call
    (command_name
      (word))
    (word)
    (parameter_list_call
      (named_parameter
        (variable_name)
        (number))
      (dict
        (variable_name)
        (number)
        (variable_name)
        (dict
          (variable_name)
          (string))))))
===========================
Multiline command arguments
===========================
json write (space=0, {
    status: 302,
    headers: {
        location: '/',
    },
},)
---
(program
  (command_call
    (command_name
      (word))
    (word)
    (parameter_list_call
      (named_parameter
        (variable_name)
        (number))
      (dict
        (variable_name)
        (number)
        (variable_name)
        (dict
          (variable_name)
          (string))))))
============
Execute file
============
./run.ysh build
---
(program
  (command_call
    (command_name
      (word))
    (word)))
===================
Proc with out param
===================
hay define Service

proc set-port (port_num;; out) {
  call out->setValue("localhost:$port_num")
}

Service foo {
  set-port 80 (&p1)
  set-port 81 (&p2)
}
---
(program
  (command_call
    (command_name
      (word))
    (word)
    (word))
  (proc_definition
    (proc_name)
    (proc_parameter_list
      (variable_name)
      (variable_name))
    (proc_block
      (expression_mode
        (variable_name)
        (method_call
          (function_name
            (variable_name))
          (string
            (expansion
              (variable_name)))))))
  (command_call
    (command_name
      (word))
    (word)
    (block
      (command_call
        (command_name
          (word))
        (number)
        (parameter_list_call
          (unary_expression
            (variable_name))))
      (command_call
        (command_name
          (word))
        (number)
        (parameter_list_call
          (unary_expression
            (variable_name)))))))
============================
Command chain and statements
============================
if test -f $myfile && test -f $myfile2 {
  rm $myfile $myfile2
}

true && echo works || if (val) { echo "doesn't work" }
---
(program
  (if_statement
    (command_call
      (command_name
        (word))
      (word)
      (expansion
        (variable_name))
      (command_call
        (command_name
          (word))
        (word)
        (expansion
          (variable_name))))
    (block
      (command_call
        (command_name
          (word))
        (expansion
          (variable_name))
        (expansion
          (variable_name)))))
  (command_call
    (command_name
      (word))
    (command_call
      (command_name
        (word))
      (word)
      (if_statement
        (variable_name)
        (block
          (command_call
            (command_name
              (word))
            (string)))))))
========================
Invalid chain statements
:error
========================
if true {
  echo works
} || echo false
---
===============
True as command
===============
true
---
(program
  (command_call
    (command_name
      (word))))
==============
Lazy arguments
==============
assert [fromJson(a) === fromJson(b)]
---
(program
  (command_call
    (command_name
      (word))
    (parameter_list_call
      (binary_expression
        (function_call
          (function_name
            (variable_name))
          (variable_name))
        (function_call
          (function_name
            (variable_name))
          (variable_name))))))
============
<() operator
============
diff <(write $one) <(write $two)
---
(program
  (command_call
    (command_name
      (word))
    (redirection
      (command_call
        (command_name
          (word))
        (expansion
          (variable_name))))
    (redirection
      (command_call
        (command_name
          (word))
        (expansion
          (variable_name))))))
================
- as command arg
================
echo -
---
(program
  (command_call
    (command_name
      (word))
    (word)))
=========================
Proc in multiline command
=========================
... json write ({
      pred,
      condition,
      block: block.sourceCode().code_str
    }) | tr -d u'\n' >> $[ENV.CALLBACKFD] &
---
(program
  (multiline_command_call
    (command_name
      (word))
    (word)
    (parameter_list_call
      (dict
        (variable_name)
        (variable_name)
        (variable_name)
        (variable_name)
        (method_call
          (function_name
            (variable_name)))
        (variable_name)))
    (command_call
      (command_name
        (word))
      (word)
      (string
        (escape_sequence))
      (redirection
        (expansion
          (variable_name)
          (variable_name))))))
==================
Invalid terminator
:error
==================
echo lol | var x &
---
